# Static, Inline, Friend

## Table of Content
- [Inline](#inline)
- [Правило одого определения](#%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%BE-%D0%BE%D0%B4%D0%BE%D0%B3%D0%BE-%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%B8%D1%8F)
- [Friend](#friend)
- [Глобальные переменные](#%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5)
- [Статические глобальные переменные](#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%B3%D0%BB%D0%BE%D0%B1%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5)
- [Статическая локальная переменная](#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B0%D1%8F-%D0%BB%D0%BE%D0%BA%D0%B0%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F)
- [Статические функции](#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D1%84%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D0%B8)
- [Статические поля класса](#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BF%D0%BE%D0%BB%D1%8F-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0)
- [Статические методы](#%D1%81%D1%82%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B5-%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D1%8B)
- [Singleton](#singleton)

## Inline
1. Советует компилятору встроить данную функцию
1. В месте вызова `inline` функции должно быть известно её определение
1. `inline`функции можно определять в заголовочных файлах
1. Все методы, определённые внутри класса, являются `inline`.
1. При линковке из всех версий `inline`-функции выбирается только одна.
1. Все определения одной и той же `inline` функции должны быть идентичны
1. `inline` - это совет компилятору, а не указ

## Правило одого определения
1. В пределах любой единицы трансляции сущности не могут иметь более одного определения (этап компиляции).
1. В пределах программы глобальные переменные и не-`inline` функции не могут иметь больше одного определения (этап линковки).
1. Классы и `inline` функции могут определяться в более чем одной единице трансляции, но определения обязанны совпадать.

## Friend
1. Дружественный класс имеет доступ к приватным полям своего друга.
1. Дружественная функция имеет доступ к приватным полям класса. Эту функцию нужно определить внутри класса с ключевым словом `friend` (удобно для переопределения операторов)
    ```cpp
    struct String {
        ...
        friend std::ostream & operator << (std::ostream & os, String const & s) {
            return os << s.data_;
        }
    private:
        size_t size_;
        char * data_;
    };
    ```
1. Для одного класса можно определить дружественным метод другого класса.
    ```cpp
    struct String;
    struct StringBuffer {
        void append (string const & s);
        void append (char const * s) { ... };
    };

    struct String {
        friend void StringBuffer::append(String const & s);
    };

    void StringBuffer::append(String const & s) {
        append(s.data_);
    }
    ```
1. Отношение дружбы
    * Отношение дружбы не симметрично (из A друг Б не следует что Б друг А)
    * Отношение дружбы н етранзитивно (из А друг Б и Б друг С не следует что А друг С)
    * Отношение дружбы сильнее, чем отношение наследования
1. Вывод: стоит избегать ключевого слова `friend`, так как оно нарушеает инкапсуляцию.

## Глобальные переменные
1. Объявление глобальных переменных

    ```cpp
    extern int global;
    ```

1. Определение глобальное переменной

    ```cpp
    global = 10;
    ```

1. При отсутствии определения, инициализируются 0 (в отличии от локальных переменных).

1. Время жизни:
    * Инициализируются при запуске программы
    * Заканчивается при выходе из программы

1. Хранится в специальном разделе памяти для хранения глобальных переменных.

1. Недостатки
    * _Мастабируемость_. К примеру есть объект использующий глобальную переменную, тогда нам нужно будет контролировать их взаимодейтвие друг с другом. Усложнится многопоточная разработка.
    * _Побочные эффекты_ - т.е. поведение функции зависит не только от её аргументов.
    * _Порядок инициализации_ - порядок инициализации не определён, и как следствие может возникнуть неопределенность в определении этих переменных.

## Статические глобальные переменные
1. Статическая глобальне переменная - это глобальная переменная, доступная только в пределах модуля.
1. Определение
    ```cpp
    static int global = 10;

    void f () {
        ++global;
    }
    ```
1. В соседнем модуле можно определить статическую глобальную переменную с таким же именем.
1. Проблемы:
    * Масштабируемость (многопоточность)
    * Побочные эффекты

## Статическая локальная переменная
1. Статическая локальная переменная - это глобальная переменная, доступная только в пределах функции.

1. Время жизни такой переменной - от первого вызова функции до конца программы.

1. Пример:
    ```cpp
    int next(int start = 0) {
        static int k = start;
        return k++;
    }

    next(10); // 10
    next(20); // 11
    ```
1. Проблемы:
    * Мастабируемость
    * Побочные эффекты

## Статические функции
1. Статическая функция - это функция, доступная только в пределах модуля
1. В разных `.cpp` файлах можно определить статические функции с одним и тем же именем.
1. Статические глобальные переменные и статические функции проходят _внутреннюю линковку_.

## Статические поля класса
1. Статические поля класса - это глобальные переменные, определённые внутри класса.

    ```cpp
    struct User {
        User() {
            ++instances_;
        }

        ~User() {
            --instances_;
        }
    private:
        static size_t instances_;
    }

    size_t User::instances_ = 0;
    ```
1. Определить такую переменную нужно снаружи класса.
1. Для доступа к статическим полям не нужен объект.

## Статические методы
1. Статические методы - функции определённые внутри класса и имеющие доступ к закрытым полям и методам.

    ```cpp
    struct User {
        ...
        static size_t count() { return instances_; }
        static void transform(User user) {
            // we are able to access private fields
        }
    private:
        static size_t instances_;
    }
    ```

## Singlteon

```cpp
struct Singleton {
    static Singleton & instance() {
        static Singleton s;
        return s;
    }
private:
    Singleton () {}
    Singleton(Singleton const &);
    Singleton & operator=(Singleton const &);
};

Singleton & s = Singleton::instance();
```
