# C++

## Table Of Content
* [Указатели](#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8)
* [Массивы](#%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
* [Использование указателей](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9)

## Указатели
1. Указатель - это переменная, хранящая адрес некоторой ячейки памяти
1. Указатели являются типизированными
    ```cpp
    int i = 3; // переменная типа int
    int *p = 0; // указатель на переменную типа int
    ```
1. Нулевому указателю (которому присовено значение **0**) не соостветствует никакая ячейка памяти
1. **&** - оператор взятия адреса переменной
1. **\*** - оператор разыменования (получает значение по адресу)
    ```cpp
    p = &i; \\ указатель р указывает на переменную i
    *p = 10; \\ изменяется ячейка по адресу p, т.е. i
    ```

## Массивы
1. Массив - набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу
1. С++ позволяет определять массивы на стеке
    ```cpp
    // array 1 2 3 4 5 0 0 0 0 0
    int m[10] = { 1, 2, 3, 4, 5};
    ```
1. Переменная массива хранит указатель на первый элемент этого массива.
1. Получение значения по индексу работает следующим образом
    ```
    m[i] => *(m + i)
    ```
1. Арифметика указателей
    ```cpp
    int m[10] = {1, 2, 3, 4, 5};
    int *p = &m[0]; // адрес начала массива
    int *q = &m[9]; // адрес последнего элемента массива
    ```
    * `(p + k)` - сдвиг на `k` ячеек типа _int_ вправо
    * `(p - k)` - сдвиг на `k` ячеек типа _int_ влево
    * `(q - p)` - количество ячеек между указателями
    * `p[k]` - эквивалентно `*(p + k)`
1. Заполнениие массива по указателю
    ```cpp
    int m[10] = {};
    for (int *p = m; p < m+9; ++p)
    {
        *p = (p - m) + 1;
    }
    // массив заполнен числами от 1 до 10
    ```
1. Передача массива в функцию
    ```cpp
    int max_element (int *m, int size) {
        int max = *m;
        for (int i = 1; i < size; ++i) {
            if (m[i] > max) {
                max = m[i];
            }
        }
        return max
    }
    ```

## Использование указателей
1. Для передачи массива в фунцию - передаём указатель на начало и указатель на следующий за последним элемен (тем самым избегая лишней операции - ` m[i] => *(m + i)`)
    ```cpp
    bool contains(int *p, int *q, int value) {
        for (;, p!=q, ++p) {
            if (*p == value) {
                return true;
            }
        }
        return false;
    }
    ```

1. Возврат указателя из функции
    ```cpp
    int * max_element (int *p, int *q) {
        int* pmax = p;
        for(; p != q; ++p) {
            if (*p > *pmax) {
                pmax = p;
            }
        }

        return pmax;
    }
    ```

1. Возврат значения через укзатель
    ```cpp
    bool max_element (int *p, int *q, int *res) {
        if (p == q) {
            return false;
        }

        *res = *p;
        for(; p!=q; ++p) {
            if (*p > *res) {
                *res = *p;
            }
        }
        return true;
    }

## Ссылки
1. Недостатки указателей
    * Использование указателей синтатически загрязняет код и усложняет его понимание (Приходится использовать операторы `*` и `&`).
    * Указатели могут быть неинициализированными (некорректный код).
    * Указатель может быть нулевым (корректный код), а значит **указатель нужно проверять на равенство нулю**.
    * Арифметика указателей может сделать из корректного указателя некорректный (легко промахнуться)

1. Ссылки
    * Для того, чтобы исправить некоторые недостатки указателей, в `С++` введены ссылки
    * Ссылки являются "красивой обёрткой" над указателями
        ```cpp
        void swap (int & a, int & b) {
            int t = b;
            b = a;
            a = t;
        }
        ```
    * Простыми словами ссылка это псевдоним переменной
1. Различия ссылок и указателей
    * Ссылка не может быть неиницилазированной
        ```cpp
        int *p; // ok
        int &l; // error
        ```
    * У ссылки нет нулевого значения
        ```cpp
        int *p = 0; // ok
        int &l = 0; // error
        ```
    * Ссылку нельзя переинициализировать
        ```cpp
        int a = 10;
        int b = 20;
        int *p = &a; // р указывает на а
        p = &b; // p указывает на b
        int &l = a; // l ссылается на а
        l = b; // a присваивается значение b
        ```
    * Нельзя создавать массивы ссылок
    * У ссылок нет арифметики
1. Следует следить за временем жизни переменных (чтобы время жизни указателей и ссылок всегда соответствовало времени жизни тех данных, на которые они указывают):
    ```cpp
    int * foo() {
        int a = 10;
        return &a;
    }

    int & bar() {
        int b = 20;
        return b;
    }

    int *p = foo(); // runtime error
    int &l = bar(); // runtime error
    ```

1. С помощью ссылки сделать параметром функции массив заданной длинны

    ```cpp
    void foo(int (&a)[3]) { /* ... */ }
    ```
1. Ссылки можно использовать не только для передачи изменяемых параметров в функции, но и для передачи больших параметров копировать которые дорого. Если при этом параметр не должен изменяться можно объявить его с ключевым словом `const`.
    ```cpp
    int foo(string const &s) { /* нельзя менять значение s */ }
    ```
