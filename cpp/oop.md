# ООП

## Наследование
1. Наследование - это механизм, позволяющий создавать производные классы, расширяя уже существующие.
1. Внутри объекта класс-наследника хранится экземпляр родительского класса
    ```
    | Person       |
    | name_ | age_ |

    | Student             |
    | name_ | age_ | uni_ |
    ```
1. При создании производного класса сначала вызывается конструктор родительского класса.
    ```cpp
    struct Person {
        Person(string name, int age)
            : name_(name), age_(age)
        {}
    };

    struct Student : Person {
        Student (string name, int age, string uni)
            : Person(name, age), uni_(uni)
        {}
    };
    ```
1. После деструктора `Student` вызывается деструктор `Person`.

## Приведение
1. Для произвольных классов определены следующие приведения:
    ```cpp
    Student s("Alex", 21, "Oxford");
    Person & l = s; // Student & => Person &
    Person *r = &s; // Student * => Person *
    ```
1. Поэтому объекты класса-наследника могут присваиваться объектам родительского класса:
    ```cpp
    Student s("Alex", 21, "Oxford");
    Person p = s; // Person("Alex", 21);
    ```
1. При этом копируются только поля класса-родителя (срезка). Т.е. в данном случае вызывается конструктор копирования `Person (Person const &p)`, который ничего не знает про `uni_`.

## Перегрузка
1. В С++ можно определить несколько функций с одинаковым именем, но разными параметрами.
1. При вызове функции по имени будет произведен поиск наиболее подходящей функции.
1. Правила перегрузки:
    1. Если есть точное совпадение, то используется оно.
    1. Если нет функции, которая могла бы подойти с учётом преобразований, выдаётся ошибка.
    1. Есть функции подходящие с учётом преобразований:
        1. Расширение типов (из меньшего типа получаем больший)
            * `char, signed char, short => int`
            * `unsigned char, unsigned short => int/unsigned int`
            * `float => double`
        1. Стандартные преобразования
            * `double` => `int`
            * указатель на производный клас => указатель на базовый класс
            * указатель на int => указатель на void
        1. Пользовательские преобразования - самые дорогие преобразования, т.к. самые медленные
            * в классе `a` определён конструктор от типа `b`
1. В случае нескольких вариантов функции одна из них должна быть строго лучше других. Т.е. по каждому параметру она должна иметь преобразование не хуже чем у других функций и хотя бы по одному параметру преобразование лучше чем у других функций.
1. Перегрузка выполняется на этапе компиляции.
1. Не стоит злоупотреблять неочевидными перегрузками!
