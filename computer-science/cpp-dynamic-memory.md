# Динамическая память

## Мотивация
1. Стек программы ограничен. Он не предназначен для хранения больших объёмов данных
    ```cpp
    // не умещается на стек
    double m[100000000] = {}; // 80 Mb
    // => segmentation fault or access violation error
    ```
1. Время жизни локальных переменных ограниченно временем работы функции
1. Динамическая память выделяется в сегменте данных.
1. Структура, отвечающая за выделение дополнительной памяти, называют **кучей**.

## Выделение памяти в стиле С
1. Стандартная библиотека `cstdlib` предоставляет четыре функции для управления памятью:

    ```cpp
    void * malloc (size_t size);
    void free (void * ptr);
    void * calloc (size_t nmemb, size_t size);
    void * realloc (void * ptr, size_t size);
    ```
1. `size_t` - специальный целочисленный беззнаковый тип, может вместить в себя размер любого типа в байтах. ( `int`'a не всегда достаточо)
1. Тип `size_t` используется для указания размеров типов данных, для индексации массивов и пр.
1. `void *` - это указатель на нетипизированную память (раньше для этого использовалось `char *`)
1. `malloc` - выделяет область памяти размера `>= size`. Не кратный размер памяти выделяется по следующим причинам
     * вначало участка памяти записывается служебная информация
     * участок памяти выделяется кратным 16
1. `calloc` - выделяет массив из `nmemb` размера `size`. Данные инициализируются нулём.
1. `realloc` - изменяет размер области памяти по указателю `ptr` на `size` (если возможно, то это делается на месте).
1. `free` - освобождает облать памяти, ранее выделенную одной из функций `malloc/calloc/realloc`.
1. Для указания размера типа используется оператор `sizeof`.
    ```cpp
    // create an array of 1000 int
    int * m  = (int *)malloc(1000 * sizeof(int));
    m[10] = 10;

    // change array size to 2000
    m = (int *)realloc(m, 2000 * sizeof(int));

    // free memory
    free (m);

    // create an array of int and inicialize it with 0
    m = (int *)calloc(3000, sizeof(int));

    free(m);
    m = 0; // best practise
    ```

## Выделение памяти в стиле С++
1. Язык С++ предоставляет два набора операторов для выделения памяти:
    * `new` и `delete` - для одиночных значений,
    * `new[]` и `delete[]` - для массивов.
1. Версия оператора `delete` должна соответствовать версии оператора `new`.
    ```cpp
    // выделение памяти под один int со значением 5
    int * m = new int(5);
    delete m; // освобождение памяти

    // создание массива нулей
    m = new int[1000];
    delete [] m; // освобождение памяти
    ```

## Типичные проблемы при работе с памятью
1. Проблемы производительности: создание переменной на стеке намного "дешевлу" выделения для неё динамической памяти.
1. Проблема фрагментации: выделение большого количества небольших сегментов способствует фрагментации памяти.
1. Утечки памяти
    ```cpp
    int * m = new int[1000];

    m = new int[2000]; // потеряли указатель но массив из 1000 элементов => утечка памяти

    // не вызван delete [] m => утечка памяти
    ```

