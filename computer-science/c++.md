# C++

## Table Of Content
* [Компиляция](#%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
* [g++](#g)
* [Указатели](#%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B8)
* [Массивы](#%D0%BC%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B)
* [Использование указателей](#%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%83%D0%BA%D0%B0%D0%B7%D0%B0%D1%82%D0%B5%D0%BB%D0%B5%D0%B9)

## Компиляция

1. **Препроцессор**
    * Язык препроцессора - это специальный язык программирования, встроенный с С++ю
    * Препроцессор работает с кодом на С++ как с текстом.
    * Команды языка препроцессор называют директивами, все директивы начинаются со знака #.
    * Директива `#include` позволяет подключать заголовочные файлы к файлам кода.
        * `#include <foo.h>` - библиотечный заголовочный файл
        * `#include "foo.h"` - локальный заголовочный файл
    * Препроцессор заменяет директиву `#include "bar.h"` на содержимое файла _bar.h_.
2. **Компиляция**
    * На вход компилятору поступает код на С++ после обработки препроцессором.
    * Каждый файл с кодом компилируется отдельно и независимо от других файлов с кодом.
    * Компилируются только файлы с кодом (т.е. *.срр).
    * Заголовочные файлы сами по себе ни во что не компилируются, только в составе файлов с кодом.
    * На выходе компилятора из каждого файла с кодом получается **объектный файл** - бинарный файл со скомпилированным кодом (с расширением `.o` или `.obj`)
3. **Линтовка (компоновка)**
    * На этом этапе все объектные файлы объединияются в один исполняемый (или библиотечный) файлю
    * При этом происходит подстановка адресов функций в места их вызова.
        ```cpp
        void foo()
        {
            bar(); //add address of bar, e.g. 0x087A
        }
        void bar() { }
        ```
    * По каждому объектному файлу строится таблица функций, которые в нём определены.
    * На этапе компоновки важно, что каждая функция имеет уникальное имя.
    * В С++ может быть две функции с одним именем, но разными параметрами. Для того чтобы функции имели уникальные имена они искажаются (mangle) таким образом, что в их имени кодируются их параметры. Например, комплятора GCC превратит имя функции `foo`
        ```cpp
        void foo(int, double) {} // _Z3foooid
        ```
    * Аналогично в линтовке нуждаются глобальные переменные.
    * Точка входа - функция, вызываемая при запуске программы. По умолчанию это функция `main`.
        ```cpp
        int main()
        {
            return 0;
        }
        ```
        или
        ```cpp
        int main(int argc, char ** argv)
        {
            return 0;
        }
        ```

## g++
1. **g++** - обёртка над набором программ (препроцессор, компилятор и линтовщик). Запускает нужную утилиту или последовательность утилит в зависимости от входных параметров.
1. Запустить препроцессор на файле:
    ```bash
    g++ -E main.cpp -o main_preprocessed.cpp
    ```
1. Запуск компилятора
    ```bash
    g++ -с main.cpp
    ```
1. Компоновка
    ```bash
    g++ file1.o main.o -o programm
    ```
1. Для того чтобы запустить препроцессор, компилятор и компоновщик одной командой
    ```bash
    g++ file1.cpp main.cpp -o programm
    ```

## Указатели
1. Указатель - это переменная, хранящая адрес некоторой ячейки памяти
1. Указатели являются типизированными
    ```cpp
    int i = 3; // переменная типа int
    int *p = 0; // указатель на переменную типа int
    ```
1. Нулевому указателю (которому присовено значение **0**) не соостветствует никакая ячейка памяти
1. **&** - оператор взятия адреса переменной
1. **\*** - оператор разыменования (получает значение по адресу)
    ```cpp
    p = &i; \\ указатель р указывает на переменную i
    *p = 10; \\ изменяется ячейка по адресу p, т.е. i
    ```

## Массивы
1. Массив - набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу
1. С++ позволяет определять массивы на стеке
    ```cpp
    // array 1 2 3 4 5 0 0 0 0 0
    int m[10] = { 1, 2, 3, 4, 5};
    ```
1. Переменная массива хранит указатель на первый элемент этого массива.
1. Получение значения по индексу работает следующим образом
    ```
    m[i] => *(m + i)
    ```
1. Арифметика указателей
    ```cpp
    int m[10 ] = {1, 2, 3, 4, 5};
    int *p = &m[0]; // адрес начала массива
    int *q = &m[9]; // адрес последнего элемента массива
    ```
    * (p + k) - сдвиг на **k** ячеек типа _int_ вправо
    * (p - k) - сдвиг на **k** ячеек типа _int_ влево
    * (q - p) - количество ячеек между указателями
    * p[k] - эквивалентно **\*(p + k)
1. Заполнениие массива по указателю
    ```cpp
    int m[10] = {};
    for (int *p = m; p < m+9; ++p)
    {
        *p = (p - m) + 1;
    }
    // массив заполнен числами от 1 до 10
    ```
1. Передача массива в функцию
    ```cpp
    int max_element (int *m, int size) {
        int max = *m;
        for (int i = 1; i < size; ++i) {
            if (m[i] > max) {
                max = m[i];
            }
        }
        return max
    }
    ```

## Использование указателей
1. Для передачи массива в фунцию - передаём указатель на начало и указатель на следующий за последним элемен (тем самым избегая лишней операции - ` m[i] => *(m + i)`)
    ```cpp
    bool contains(int *p, int *q, int value) {
        for (;, p!=q, ++p) {
            if (*p == value) {
                return true;
            }
        }
        return false;
    }
    ```

1. Возврат указателя из функции
    ```cpp
    int * max_element (int* p, int* q) {
        int* pmax = p;
        for(; p != q; ++p) {
            if (*p > *pmax) {
                pmax = p;
            }
        }

        return pmax;
    }
    ```

1. Возврат значения через укзатель
    ```cpp
    bool max_element (int *p, int *q, int *res) {
        if (p == q) {
            return false;
        }

        *res = *p;
        for(; p!=q; ++p) {
            if (*p > *res) {
                *res = *p;
            }
        }
        return true;
    }
