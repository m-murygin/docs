# C++

## Компиляция

1. **Препроцессор**
    * Язык препроцессора - это специальный язык программирования, встроенный с С++ю
    * Препроцессор работает с кодом на С++ как с текстом.
    * Команды языка препроцессор называют директивами, все директивы начинаются со знака #.
    * Директива `#include` позволяет подключать заголовочные файлы к файлам кода.
        * `#include <foo.h>` - библиотечный заголовочный файл
        * `#include "foo.h"` - локальный заголовочный файл
    * Препроцессор заменяет директиву `#include "bar.h"` на содержимое файла _bar.h_.
2. **Компиляция**
    * На вход компилятору поступает код на С++ после обработки препроцессором.
    * Каждый файл с кодом компилируется отдельно и независимо от других файлов с кодом.
    * Компилируются только файлы с кодом (т.е. *.срр).
    * Заголовочные файлы сами по себе ни во что не компилируются, только в составе файлов с кодом.
    * На выходе компилятора из каждого файла с кодом получается **объектный файл** - бинарный файл со скомпилированным кодом (с расширением `.o` или `.obj`)
3. **Линтовка (компоновка)**
    * На этом этапе все объектные файлы объединияются в один исполняемый (или библиотечный) файлю
    * При этом происходит подстановка адресов функций в места их вызова.
        ```cpp
        void foo()
        {
            bar(); //add address of bar, e.g. 0x087A
        }
        void bar() { }
        ```
    * По каждому объектному файлу строится таблица функций, которые в нём определены.
    * На этапе компоновки важно, что каждая функция имеет уникальное имя.
    * В С++ может быть две функции с одним именем, но разными параметрами. Для того чтобы функции имели уникальные имена они искажаются (mangle) таким образом, что в их имени кодируются их параметры. Например, комплятора GCC превратит имя функции `foo`
        ```cpp
        void foo(int, double) {} // _Z3foooid
        ```
    * Аналогично в линтовке нуждаются глобальные переменные.
    * Точка входа - функция, вызываемая при запуске программы. По умолчанию это функция `main`.
        ```cpp
        int main()
        {
            return 0;
        }
        ```
        или
        ```cpp
        int main(int argc, char ** argv)
        {
            return 0;
        }
        ```

## g++
1. **g++** - обёртка над набором программ (препроцессор, компилятор и линтовщик). Запускает нужную утилиту или последовательность утилит в зависимости от входных параметров.
1. Запустить препроцессор на файле:
    ```bash
    g++ -E main.cpp -o main_preprocessed.cpp
    ```
1. Запуск компилятора
    ```bash
    g++ -с main.cpp
    ```
1. Компоновка
    ```bash
    g++ file1.o main.o -o programm
    ```
1. Для того чтобы запустить препроцессор, компилятор и компоновщик одной командой
    ```bash
    g++ file1.cpp main.cpp -o programm
    ```

## Указатели
1. Указатель - это переменная, хранящая адрес некоторой ячейки памяти
1. Указатели являются типизированными
    ```cpp
    int i = 3; // переменная типа int
    int *p = 0; // указатель на переменную типа int
    ```
1. Нулевому указателю (которому присовено значение **0**) не соостветствует никакая ячейка памяти
1. **&** - оператор взятия адреса переменной
1. **\*** - оператор разыменования (получает значение по адресу)
    ```cpp
    p = &i; \\ указатель р указывает на переменную i
    *p = 10; \\ изменяется ячейка по адресу p, т.е. i
    ```

## Массивы
1. Массив - набор однотипных элементов, расположенных в памяти друг за другом, доступ к которым осуществляется по индексу
1. С++ позволяет определять массивы на стеке
    ```cpp
    // array 1 2 3 4 5 0 0 0 0 0
    int m[10] = { 1, 2, 3, 4, 5};
    ```
1. Арифметика указателей
    ```cpp
    int m[10 ] = {1, 2, 3, 4, 5};
    int *p = &m[0]; // адрес начала массива
    int *q = &m[9]; // адрес последнего элемента массива
    ```
    * (p + k) - сдвиг на **k** ячеек типа _int_ вправо
    * (p - k) - сдвиг на **k** ячеек типа _int_ влево
    * (q - p) - количество ячеек между указателями
    * p[k] - эквивалентно **\*(p + k)
1. Заполнениие массива по указателю
    ```cpp
    int m[10] = {};
    for (int *p = m; p < m+9; ++p)
    {
        *p = (p - m) + 1;
    }
    // массив заполнен числами от 1 до 10
    ```
1. Передача массива в функцию
    ```cpp
    int max_element (int *m, int size) {
        int max = *m;
        for (int i = 1; i < size; ++i) {
            if (m[i] > max) {
                max = m[i];
            }
        }
        return max
    }
    ```
